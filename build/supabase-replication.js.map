{
  "version": 3,
  "sources": ["../src/supabase-replication.ts"],
  "sourcesContent": ["import { RealtimeChannel, SupabaseClient } from \"@supabase/supabase-js\"\nimport {\n  ReplicationOptions,\n  ReplicationPullHandlerResult,\n  ReplicationPullOptions,\n  ReplicationPushOptions,\n  RxReplicationPullStreamItem,\n  RxReplicationWriteToMasterRow,\n  WithDeleted,\n} from \"rxdb\"\nimport { RxReplicationState } from \"rxdb/plugins/replication\"\nimport { Subject } from \"rxjs\"\n\nconst DEFAULT_LAST_MODIFIED_FIELD = \"_modified\"\nconst DEFAULT_DELETED_FIELD = \"_deleted\"\nconst POSTGRES_DUPLICATE_KEY_ERROR_CODE = \"23505\"\n\nexport type SupabaseReplicationOptions<RxDocType> = {\n  /**\n   * The SupabaseClient to replicate with.\n   */\n  supabaseClient: SupabaseClient\n\n  /**\n   * The table to replicate to, if different from the name of the collection.\n   * @default the name of the RxDB collection.\n   */\n  table?: string\n\n  /**\n   * The primary key of the supabase table, if different from the primary key of the RxDB.\n   * @default the primary key of the RxDB collection\n   */\n  // TODO: Support composite primary keys.\n  primaryKey?: string\n\n  /**\n   * Options for pulling data from supabase. Set to {} to pull with the default\n   * options, as no data will be pulled if the field is absent.\n   */\n  pull?: Omit<\n    ReplicationPullOptions<RxDocType, SupabaseReplicationCheckpoint>,\n    \"handler\" | \"stream$\"\n  > & {\n    /**\n     * Whether to subscribe to realtime Postgres changes for the table. If set to false,\n     * only an initial pull will be performed. Only has an effect if the live option is set\n     * to true.\n     * @default true\n     */\n    realtimePostgresChanges?: boolean\n\n    /**\n     * The name of the supabase field that is automatically updated to the last\n     * modified timestamp by postgres. This field is required for the pull sync\n     * to work and can easily be implemented with moddatetime in supabase.\n     * @default '_modified'\n     */\n    lastModifiedField?: string\n  }\n\n  /**\n   * Options for pushing data to supabase. Set to {} to push with the default\n   * options, as no data will be pushed if the field is absent.\n   */\n  // TODO: enable custom batch size (currently always one row at a time)\n  push?: Omit<ReplicationPushOptions<RxDocType>, \"handler\" | \"batchSize\"> & {\n    /**\n     * Handler for pushing row updates to supabase. Must return true iff the UPDATE was\n     * applied to the supabase table. Returning false signalises a write conflict, in\n     * which case the current state of the row will be fetched from supabase and passed to\n     * the RxDB collection's conflict handler.\n     * @default the default handler will update the row only iff all fields match the\n     * local state (before the update was applied), otherwise the conflict handler is\n     * invoked. The default handler does not support JSON fields at the moment.\n     */\n    // TODO: Support JSON fields\n    updateHandler?: (row: RxReplicationWriteToMasterRow<RxDocType>) => Promise<boolean>\n  }\n} & Omit<\n  // We don't support waitForLeadership. You should just run in a SharedWorker anyways, no?\n  ReplicationOptions<RxDocType, any>,\n  \"pull\" | \"push\" | \"waitForLeadership\"\n>\n\n/**\n * The checkpoint stores until which point the client and supabse have been synced.\n * For this to work, we require each row to have a datetime field that contains the\n * last modified time. In case two rows have the same timestamp, we use the primary\n * key to define a strict order.\n */\nexport interface SupabaseReplicationCheckpoint {\n  modified: string\n  primaryKeyValue: string | number\n}\n\n/**\n * Replicates the local RxDB database with the given Supabase client.\n *\n * See SupabaseReplicationOptions for the various configuration options. For a general introduction\n * to RxDB's replication protocol, see https://rxdb.info/replication.html\n */\nexport class SupabaseReplication<RxDocType> extends RxReplicationState<\n  RxDocType,\n  SupabaseReplicationCheckpoint\n> {\n  private readonly table: string\n  private readonly primaryKey: string\n  private readonly lastModifiedFieldName: string\n\n  private readonly realtimeChanges: Subject<\n    RxReplicationPullStreamItem<RxDocType, SupabaseReplicationCheckpoint>\n  >\n  private realtimeChannel?: RealtimeChannel\n\n  constructor(private options: SupabaseReplicationOptions<RxDocType>) {\n    const realtimeChanges = new Subject<\n      RxReplicationPullStreamItem<RxDocType, SupabaseReplicationCheckpoint>\n    >()\n    super(\n      options.replicationIdentifier,\n      options.collection,\n      options.deletedField || DEFAULT_DELETED_FIELD,\n      options.pull && {\n        ...options.pull,\n        stream$: realtimeChanges,\n        handler: (lastCheckpoint, batchSize) => this.pullHandler(lastCheckpoint, batchSize),\n      },\n      options.push && {\n        ...options.push,\n        batchSize: 1, // TODO: support batch insertion\n        handler: (rows) => this.pushHandler(rows),\n      },\n      typeof options.live === \"undefined\" ? true : options.live,\n      typeof options.retryTime === \"undefined\" ? 5000 : options.retryTime,\n      typeof options.autoStart === \"undefined\" ? true : options.autoStart,\n    )\n    this.realtimeChanges = realtimeChanges\n    this.table = options.table || options.collection.name\n    this.primaryKey = options.primaryKey || options.collection.schema.primaryPath\n    this.lastModifiedFieldName = options.pull?.lastModifiedField || DEFAULT_LAST_MODIFIED_FIELD\n\n    if (this.autoStart) {\n      this.start()\n    }\n  }\n\n  public override async start(): Promise<void> {\n    if (\n      this.live &&\n      this.options.pull &&\n      (this.options.pull.realtimePostgresChanges ||\n        typeof this.options.pull.realtimePostgresChanges === \"undefined\")\n    ) {\n      this.watchPostgresChanges()\n    }\n    return super.start()\n  }\n\n  public override async cancel(): Promise<any> {\n    if (this.realtimeChannel) {\n      return Promise.all([super.cancel(), this.realtimeChannel.unsubscribe()])\n    }\n    return super.cancel()\n  }\n\n  /**\n   * Pulls all changes since the last checkpoint from supabase.\n   */\n  private async pullHandler(\n    lastCheckpoint: SupabaseReplicationCheckpoint,\n    batchSize: number,\n  ): Promise<ReplicationPullHandlerResult<RxDocType, SupabaseReplicationCheckpoint>> {\n    let query = this.options.supabaseClient.from(this.table).select()\n    if (lastCheckpoint && lastCheckpoint.modified) {\n      // Construct the PostgREST query for the following condition:\n      // WHERE _modified > lastModified OR (_modified = lastModified AND primaryKey > lastPrimaryKey)\n      const lastModified = JSON.stringify(lastCheckpoint.modified)\n      const lastPrimaryKey = JSON.stringify(lastCheckpoint.primaryKeyValue) // TODO: Add test for a integer primary key\n      const isNewer = `${this.lastModifiedFieldName}.gt.${lastModified}`\n      const isSameAge = `${this.lastModifiedFieldName}.eq.${lastModified}`\n      query = query.or(`${isNewer},and(${isSameAge},${this.primaryKey}.gt.${lastPrimaryKey})`)\n    }\n    query = query.order(this.lastModifiedFieldName).order(this.primaryKey).limit(batchSize)\n    //console.debug(\"Pulling changes since\", lastCheckpoint?.modified, \"with query\", (query as any)['url'].toString())\n\n    const { data, error } = await query\n    if (error) throw error\n    if (data.length == 0) {\n      return {\n        checkpoint: lastCheckpoint,\n        documents: [],\n      }\n    } else {\n      return {\n        checkpoint: this.rowToCheckpoint(data[data.length - 1]),\n        documents: data.map(this.rowToRxDoc.bind(this)),\n      }\n    }\n  }\n\n  /**\n   * Pushes local changes to supabase.\n   */\n  private async pushHandler(\n    rows: RxReplicationWriteToMasterRow<RxDocType>[],\n  ): Promise<WithDeleted<RxDocType>[]> {\n    if (rows.length != 1) throw new Error(\"Invalid batch size\")\n    const row = rows[0]\n    //console.debug(\"Pushing changes...\", row.newDocumentState)\n    return row.assumedMasterState\n      ? this.handleUpdate(row)\n      : this.handleInsertion(row.newDocumentState)\n  }\n\n  /**\n   * Tries to insert a new row. Returns the current state of the row in case of a conflict.\n   */\n  private async handleInsertion(doc: WithDeleted<RxDocType>): Promise<WithDeleted<RxDocType>[]> {\n    const { error } = await this.options.supabaseClient.from(this.table).insert(doc)\n    if (!error) {\n      return [] // Success :)\n    } else if (error.code == POSTGRES_DUPLICATE_KEY_ERROR_CODE) {\n      // The row was already inserted. Fetch current state and let conflict handler resolve it.\n      return [await this.fetchByPrimaryKey((doc as any)[this.primaryKey])]\n    } else {\n      throw error\n    }\n  }\n\n  /**\n   * Updates a row in supabase if all fields match the local state. Otherwise, the current\n   * state is fetched and passed to the conflict handler.\n   */\n  private async handleUpdate(\n    row: RxReplicationWriteToMasterRow<RxDocType>,\n  ): Promise<WithDeleted<RxDocType>[]> {\n    const updateHandler = this.options.push?.updateHandler || this.defaultUpdateHandler.bind(this)\n    if (await updateHandler(row)) return [] // Success :)\n    // Fetch current state and let conflict handler resolve it.\n    return [await this.fetchByPrimaryKey((row.newDocumentState as any)[this.primaryKey])]\n  }\n\n  /**\n   * Updates the row only if all database fields match the expected state.\n   */\n  private async defaultUpdateHandler(\n    row: RxReplicationWriteToMasterRow<RxDocType>,\n  ): Promise<boolean> {\n    let query = this.options.supabaseClient\n      .from(this.table)\n      .update(row.newDocumentState, { count: \"exact\" })\n    Object.entries(row.assumedMasterState!).forEach(([field, value]) => {\n      const type = typeof value\n      if (type === \"string\" || type === \"number\") {\n        query = query.eq(field, value)\n      } else if (type === \"boolean\" || value === null) {\n        query = query.is(field, value)\n      } else {\n        throw new Error(`replicateSupabase: Unsupported field of type ${type}`)\n      }\n    })\n    const { error, count } = await query\n    if (error) throw error\n    return count == 1\n  }\n\n  private watchPostgresChanges() {\n    this.realtimeChannel = this.options.supabaseClient\n      .channel(`rxdb-supabase-${this.replicationIdentifierHash}`)\n      .on(\"postgres_changes\", { event: \"*\", schema: \"public\", table: this.table }, (payload) => {\n        if (payload.eventType === \"DELETE\" || !payload.new) return // Should have set _deleted field already\n        //console.debug('Realtime event received:', payload)\n        this.realtimeChanges.next({\n          checkpoint: this.rowToCheckpoint(payload.new),\n          documents: [this.rowToRxDoc(payload.new)],\n        })\n      })\n      .subscribe()\n  }\n\n  private async fetchByPrimaryKey(primaryKeyValue: any): Promise<WithDeleted<RxDocType>> {\n    const { data, error } = await this.options.supabaseClient\n      .from(this.table)\n      .select()\n      .eq(this.primaryKey, primaryKeyValue)\n      .limit(1)\n    if (error) throw error\n    if (data.length != 1) throw new Error(\"No row with given primary key\")\n    return this.rowToRxDoc(data[0])\n  }\n\n  private rowToRxDoc(row: any): WithDeleted<RxDocType> {\n    // TODO: Don't delete the field if it is actually part of the collection\n    delete row[this.lastModifiedFieldName]\n    return row as WithDeleted<RxDocType>\n  }\n\n  private rowToCheckpoint(row: any): SupabaseReplicationCheckpoint {\n    return {\n      modified: row[this.lastModifiedFieldName],\n      primaryKeyValue: row[this.primaryKey],\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
